<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>온라인 오목 게임 (랜덤매칭)</title>
    <style>
        /* 기본 스타일 및 초기화 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f0f0;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 10px;
        }
        .hidden {
            display: none !important;
        }
        
        /* 로비 스타일 */
        #lobby {
            display: flex;
            flex-direction: column;
            padding: 30px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
            width: 95%;
            max-width: 400px;
        }
        #lobby h1 {
            margin-top: 0;
        }
        #lobby input {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
        }
        #lobby button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 5px;
            transition: background-color 0.2s;
        }
        #create-room-btn {
            background-color: #007bff;
            color: white;
        }
        #create-room-btn:hover { background-color: #0056b3; }
        
        #random-join-btn {
            background-color: #28a745;
            color: white;
            margin-top: 10px;
        }
        #random-join-btn:hover { background-color: #218838; }

        #join-room-btn {
            background-color: #6c757d;
            color: white;
        }
        #join-room-btn:hover { background-color: #5a6268; }

        /* 게임 화면 스타일 (이전과 동일) */
        #game-screen {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap; 
        }
        #board-container {
            position: relative;
            width: 600px;
            height: 600px;
            background-color: #e3b769;
            border: 2px solid #5c3d0d;
            flex-shrink: 0;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #game-info {
            display: flex;
            flex-direction: column;
            width: 250px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #game-info h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            font-size: 1.1em;
            word-break: break-all;
        }
        .player-info {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid transparent;
        }
        .player-info.active {
            border-color: #007bff;
            background-color: #e7f3ff;
        }
        #status-message {
            font-weight: bold;
            font-size: 1.2em;
            color: #d9534f;
            margin-top: 10px;
            min-height: 30px;
        }
        #timer-display {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            margin-top: 15px;
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        /* 반응형 (이전과 동일) */
        @media (max-width: 900px) {
            body { padding: 0; justify-content: flex-start; }
            #game-screen { flex-direction: column; align-items: center; gap: 10px; padding: 10px 0; }
            #board-container { width: 95vw; height: 95vw; max-width: 500px; max-height: 500px; }
            #game-info { width: 95vw; max-width: 500px; }
        }
    </style>
</head>
<body>

    <div id="lobby">
        <h1>온라인 오목</h1>
        <input type="text" id="nickname" placeholder="닉네임을 입력하세요">
        <button id="create-room-btn">방 만들기</button>
        <button id="random-join-btn">랜덤 참여</button>
        <hr style="width:100%; margin: 20px 0;">
        <input type="text" id="room-id-input" placeholder="참여할 방 ID(6자리 숫자) 입력">
        <button id="join-room-btn">방 참여하기</button>
    </div>

    <div id="game-screen" class="hidden">
        <div id="board-container">
            <canvas id="omok-board"></canvas>
        </div>
        <div id="game-info">
            <h2 id="room-id-display">방 ID: </h2>
            <div id="player1-info" class="player-info">
                <strong>흑돌:</strong> <span id="player1-name"></span>
            </div>
            <div id="player2-info" class="player-info">
                <strong>백돌:</strong> <span id="player2-name"></span>
            </div>
            <div id="status-message"></div>
            <div id="timer-display"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, get } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

        // Firebase 설정
        const firebaseConfig = {
            apiKey: "AIzaSyC4xAfGXIEggX-JHfLgP7Rg89kTpSR0P80",
            authDomain: "baseball-game-online.firebaseapp.com",
            databaseURL: "https://baseball-game-online-default-rtdb.firebaseio.com",
            projectId: "baseball-game-online",
            storageBucket: "baseball-game-online.firebasestorage.app",
            messagingSenderId: "780870375292",
            appId: "1:780870375292:web:3070374a4629225c4e76f9"
        };
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // --- DOM Elements ---
        const lobby = document.getElementById('lobby');
        const gameScreen = document.getElementById('game-screen');
        const nicknameInput = document.getElementById('nickname');
        const createRoomBtn = document.getElementById('create-room-btn');
        const randomJoinBtn = document.getElementById('random-join-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const roomIdInput = document.getElementById('room-id-input');
        const canvas = document.getElementById('omok-board');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const roomIdDisplay = document.getElementById('room-id-display');
        const player1Name = document.getElementById('player1-name');
        const player2Name = document.getElementById('player2-name');
        const player1Info = document.getElementById('player1-info');
        const player2Info = document.getElementById('player2-info');
        const timerDisplay = document.getElementById('timer-display');

        // --- Game Constants ---
        const BOARD_SIZE = 15;
        const TURN_TIME_SECONDS = 45; // 시간제한 45초로 변경

        // --- Game State ---
        let currentRoomId = null;
        let myPlayerNumber = null;
        let roomUnsubscribe = null;
        let turnInterval = null;
        let lastKnownGameData = null;

        // --- Lobby Logic ---
        createRoomBtn.addEventListener('click', async () => {
            const nickname = nicknameInput.value.trim();
            if (!nickname) { alert('닉네임을 입력해주세요.'); return; }
            
            // 6자리 숫자 방 ID 생성
            const roomId = (Math.floor(Math.random() * 900000) + 100000).toString(); 
            
            const roomRef = ref(database, `omok_rooms/${roomId}`);
            const initialGameState = {
                players: { 1: { nickname: nickname, ready: true } },
                board: createEmptyBoard(),
                currentPlayer: 1,
                gameState: 'waiting', winner: null
            };
            await set(roomRef, initialGameState);
            startGame(roomId, 1);
        });

        joinRoomBtn.addEventListener('click', async () => {
            const nickname = nicknameInput.value.trim();
            if (!nickname) { alert('닉네임을 입력해주세요.'); return; }
            const roomId = roomIdInput.value.trim();
            if (!roomId) { alert('방 ID를 입력해주세요.'); return; }
            
            joinSpecificRoom(roomId, nickname);
        });

        randomJoinBtn.addEventListener('click', async () => {
            const nickname = nicknameInput.value.trim();
            if (!nickname) { alert('닉네임을 입력해주세요.'); return; }

            randomJoinBtn.disabled = true;
            randomJoinBtn.textContent = '방 찾는 중...';
            
            const roomsRef = ref(database, 'omok_rooms');
            const snapshot = await get(roomsRef);
            
            const availableRooms = [];
            if (snapshot.exists()) {
                snapshot.forEach(childSnapshot => {
                    const roomData = childSnapshot.val();
                    const roomId = childSnapshot.key;
                    // 대기 중이고 플레이어가 1명인 방만 찾기
                    if (roomData.gameState === 'waiting' && roomData.players && Object.keys(roomData.players).length === 1) {
                        availableRooms.push(roomId);
                    }
                });
            }

            if (availableRooms.length > 0) {
                const randomRoomId = availableRooms[Math.floor(Math.random() * availableRooms.length)];
                await joinSpecificRoom(randomRoomId, nickname);
            } else {
                alert('참여할 수 있는 방이 없습니다. 새로운 방을 만들어주세요.');
            }
            
            randomJoinBtn.disabled = false;
            randomJoinBtn.textContent = '랜덤 참여';
        });

        async function joinSpecificRoom(roomId, nickname) {
            const roomRef = ref(database, `omok_rooms/${roomId}`);
            const snapshot = await get(roomRef);
            if (snapshot.exists()) {
                const roomData = snapshot.val();
                if (roomData.players && Object.keys(roomData.players).length < 2) {
                    const updatedData = { ...roomData,
                        players: { ...roomData.players, 2: { nickname: nickname, ready: true } },
                        gameState: 'playing'
                    };
                    await set(roomRef, updatedData);
                    startGame(roomId, 2);
                } else { alert('방이 꽉 찼거나 유효하지 않습니다.'); }
            } else { alert('방을 찾을 수 없습니다.'); }
        }

        // --- Game Setup ---
        function startGame(roomId, playerNumber) {
            currentRoomId = roomId;
            myPlayerNumber = playerNumber;
            lobby.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            roomIdDisplay.textContent = `방 ID: ${roomId}`;
            const roomRef = ref(database, `omok_rooms/${roomId}`);
            roomUnsubscribe = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    alert("방이 사라졌습니다. 로비로 돌아갑니다.");
                    window.location.reload();
                    return;
                }
                updateGame(snapshot.val());
            });
            canvas.addEventListener('click', handleBoardClick);
            window.addEventListener('resize', () => updateGame(null)); 
        }

        function createEmptyBoard() { return Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0)); }

        // --- Game Update and Drawing --- (이하 로직은 이전과 대부분 동일)
        function updateGame(gameData) {
            if(gameData) { lastKnownGameData = gameData; } 
            else if (lastKnownGameData) { gameData = lastKnownGameData; } 
            else { return; }

            drawBoard();
            drawStones(gameData.board);

            player1Name.textContent = gameData.players[1]?.nickname || '대기 중...';
            player2Name.textContent = gameData.players[2]?.nickname || '대기 중...';
            player1Info.classList.remove('active');
            player2Info.classList.remove('active');

            if (gameData.gameState === 'playing') {
                if (gameData.currentPlayer === 1) player1Info.classList.add('active');
                else if(gameData.currentPlayer === 2) player2Info.classList.add('active');
                const currentPlayerName = gameData.players[gameData.currentPlayer].nickname;
                statusMessage.textContent = `${currentPlayerName} 님의 차례입니다.`;
                startTurnTimer(gameData.currentPlayer);
            } else {
                clearInterval(turnInterval);
                timerDisplay.textContent = "게임 종료";
                if (gameData.gameState === 'waiting') {
                    statusMessage.textContent = '상대방을 기다리고 있습니다...';
                    timerDisplay.textContent = "대기 중";
                } else if (gameData.gameState === 'finished') {
                    const winnerName = gameData.players[gameData.winner].nickname;
                    statusMessage.textContent = `게임 종료! ${winnerName} 님의 승리입니다!`;
                }
            }
        }

        function drawBoard() {
            canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight;
            const CELL_SIZE = canvas.width / BOARD_SIZE; const PADDING = CELL_SIZE / 2;
            ctx.fillStyle = '#e3b769'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#5c3d0d'; ctx.lineWidth = 1;
            for (let i = 0; i < BOARD_SIZE; i++) {
                ctx.beginPath(); ctx.moveTo(PADDING + i * CELL_SIZE, PADDING); ctx.lineTo(PADDING + i * CELL_SIZE, canvas.height - PADDING); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(PADDING, PADDING + i * CELL_SIZE); ctx.lineTo(canvas.width - PADDING, PADDING + i * CELL_SIZE); ctx.stroke();
            }
            const starPoints = [{x: 3, y: 3}, {x: 11, y: 3}, {x: 3, y: 11}, {x: 11, y: 11}, {x: 7, y: 7}];
            ctx.fillStyle = '#5c3d0d';
            starPoints.forEach(p => {
                ctx.beginPath(); ctx.arc(PADDING + p.x * CELL_SIZE, PADDING + p.y * CELL_SIZE, CELL_SIZE * 0.1, 0, 2 * Math.PI); ctx.fill();
            });
        }
        
        function drawStones(board) {
            if (!board) return;
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) { if (board[y][x] !== 0) drawStone(x, y, board[y][x]); }
            }
        }

        function drawStone(x, y, player) {
            const CELL_SIZE = canvas.width / BOARD_SIZE; const PADDING = CELL_SIZE / 2; const STONE_RADIUS = CELL_SIZE * 0.45;
            const canvasX = PADDING + x * CELL_SIZE; const canvasY = PADDING + y * CELL_SIZE;
            ctx.beginPath(); ctx.arc(canvasX, canvasY, STONE_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = (player === 1) ? 'black' : 'white'; ctx.fill();
        }

        async function handleBoardClick(event) {
            const roomRef = ref(database, `omok_rooms/${currentRoomId}`); const snapshot = await get(roomRef);
            if (!snapshot.exists()) return;
            const gameData = snapshot.val();
            if (gameData.gameState !== 'playing' || gameData.currentPlayer !== myPlayerNumber) return;
            const rect = canvas.getBoundingClientRect(); const mouseX = event.clientX - rect.left; const mouseY = event.clientY - rect.top;
            const CELL_SIZE = canvas.clientWidth / BOARD_SIZE; const PADDING = CELL_SIZE / 2;
            const x = Math.round((mouseX - PADDING) / CELL_SIZE); const y = Math.round((mouseY - PADDING) / CELL_SIZE);
            if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
            if (gameData.board[y][x] !== 0) { statusMessage.textContent = '이미 돌이 있는 곳입니다.'; return; }
            if (myPlayerNumber === 1 && isForbiddenMove(x, y, 1, gameData.board)) { statusMessage.textContent = '3-3 금지 위치입니다!'; return; }
            clearInterval(turnInterval);
            await placeStone(x, y, myPlayerNumber, gameData);
        }
        
        async function placeStone(x, y, player, currentGameData) {
            const newBoard = currentGameData.board.map(row => [...row]); newBoard[y][x] = player;
            const hasWon = checkWin(x, y, player, newBoard);
            const updatedData = { ...currentGameData, board: newBoard, currentPlayer: player === 1 ? 2 : 1 };
            if (hasWon) { updatedData.gameState = 'finished'; updatedData.winner = player; }
            const roomRef = ref(database, `omok_rooms/${currentRoomId}`);
            await set(roomRef, updatedData);
        }

        function startTurnTimer(currentPlayer) {
            clearInterval(turnInterval); let timeLeft = TURN_TIME_SECONDS;
            timerDisplay.textContent = `남은 시간: ${timeLeft}초`;
            turnInterval = setInterval(async () => {
                timeLeft--; timerDisplay.textContent = `남은 시간: ${timeLeft}초`;
                if (timeLeft < 0) {
                    clearInterval(turnInterval);
                    if (myPlayerNumber === currentPlayer) {
                        statusMessage.textContent = "시간 초과! 무작위 위치에 돌을 놓습니다.";
                        await makeRandomMove();
                    }
                }
            }, 1000);
        }
        
        async function makeRandomMove() {
            const roomRef = ref(database, `omok_rooms/${currentRoomId}`); const snapshot = await get(roomRef);
            if (!snapshot.exists()) return; const gameData = snapshot.val();
            if(gameData.currentPlayer !== myPlayerNumber) return;
            const emptySpots = [];
            for (let y = 0; y < BOARD_SIZE; y++) { for (let x = 0; x < BOARD_SIZE; x++) { if (gameData.board[y][x] === 0) emptySpots.push({ x, y }); }}
            if (emptySpots.length === 0) return;
            let validMoveFound = false;
            while (emptySpots.length > 0 && !validMoveFound) {
                const randomIndex = Math.floor(Math.random() * emptySpots.length); const { x, y } = emptySpots[randomIndex];
                if (myPlayerNumber === 1 && isForbiddenMove(x, y, 1, gameData.board)) { emptySpots.splice(randomIndex, 1); }
                else { await placeStone(x, y, myPlayerNumber, gameData); validMoveFound = true; }
            }
            if (!validMoveFound) {
                statusMessage.textContent = "착수할 유효한 위치가 없습니다! 턴을 넘깁니다.";
                const updatedData = { ...gameData, currentPlayer: myPlayerNumber === 1 ? 2 : 1 };
                await set(roomRef, updatedData);
            }
        }
        
        // --- Rule Checking (이하 로직은 변경 없음) ---
        function checkWin(x, y, player, board) {
            const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }];
            for (const { dx, dy } of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) { const nx = x + i * dx, ny = y + i * dy; if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) count++; else break; }
                for (let i = 1; i < 5; i++) { const nx = x - i * dx, ny = y - i * dy; if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) count++; else break; }
                if (count >= 5) return true;
            }
            return false;
        }
        function isForbiddenMove(x, y, player, board) {
            if (player !== 1) return false;
            const tempBoard = board.map(row => [...row]); tempBoard[y][x] = player; let openThreeCount = 0;
            const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }];
            for (const { dx, dy } of directions) { if (createsOpenThree(x, y, player, tempBoard, dx, dy)) { openThreeCount++; } }
            return openThreeCount >= 2;
        }
        function createsOpenThree(x, y, player, board, dx, dy) {
            const patterns = [{ sequence: [player, 0, player, player, 0], checkIndex: 1 }, { sequence: [player, player, 0, player, 0], checkIndex: 2 },];
            for (let i = -4; i <= 0; i++) { if (checkPattern(x, y, player, board, dx, dy, i, [0, player, player, player, 0])) { const p1 = (i + 1), p2 = (i + 2), p3 = (i + 3); const placedOnX = (x === x + p1*dx && y === y + p1*dy) || (x === x + p2*dx && y === y + p2*dy) || (x === x + p3*dx && y === y + p3*dy); if(placedOnX) return true; }}
            for(const p of patterns) { for (let i = -4; i <= 0; i++) { if (checkPattern(x, y, player, board, dx, dy, i, p.sequence)) { const placedX = x + (i + p.checkIndex) * dx; const placedY = y + (i + p.checkIndex) * dy; if(x === placedX && y === placedY) return true; }}}
            return false;
        }
        function checkPattern(x, y, player, board, dx, dy, offset, pattern) {
            for (let i = 0; i < pattern.length; i++) {
                const nx = x + (i + offset) * dx; const ny = y + (i + offset) * dy;
                if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) return false;
                let boardVal = board[ny][nx]; let patternVal = pattern[i];
                if(patternVal === player && boardVal !== player) return false;
                if(patternVal === 0 && boardVal !== 0) return false;
            }
            return true;
        }
        window.addEventListener('beforeunload', () => { if (currentRoomId && roomUnsubscribe) { roomUnsubscribe(); } });
    </script>
</body>
</html>