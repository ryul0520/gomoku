<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>온라인 오목 게임 (랜덤 매칭)</title>
    <style>
        /* CSS 스타일은 이전과 동일합니다 */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; min-height: 100vh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f0f0; }
        body { display: flex; justify-content: center; align-items: center; flex-direction: column; padding: 10px; }
        .hidden { display: none !important; }
        #lobby { display: flex; flex-direction: column; padding: 30px; background-color: white; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); text-align: center; width: 95%; max-width: 400px; }
        #lobby h1 { margin-top: 0; }
        #lobby input { margin-bottom: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px; }
        #lobby button { padding: 10px 15px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; margin-top: 5px; transition: background-color 0.2s; }
        #create-room-btn { background-color: #007bff; color: white; }
        #create-room-btn:hover { background-color: #0056b3; }
        #random-match-btn { background-color: #28a745; color: white; margin-top: 10px; }
        #random-match-btn:hover { background-color: #218838; }
        #join-room-btn { background-color: #6c757d; color: white; }
        #join-room-btn:hover { background-color: #5a6268; }
        #game-screen { display: flex; gap: 20px; align-items: flex-start; justify-content: center; width: 100%; flex-wrap: wrap; }
        #board-container { position: relative; width: 600px; height: 600px; background-color: #e3b769; border: 2px solid #5c3d0d; flex-shrink: 0; }
        canvas { display: block; width: 100%; height: 100%; }
        #game-info { display: flex; flex-direction: column; width: 250px; padding: 20px; background-color: white; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        #game-info h2 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; font-size: 1.1em; word-break: break-all; }
        .player-info { margin: 10px 0; padding: 10px; border-radius: 5px; border: 2px solid transparent; }
        .player-info.active { border-color: #007bff; background-color: #e7f3ff; }
        #status-message { font-weight: bold; font-size: 1.2em; color: #d9534f; margin-top: 10px; min-height: 30px; }
        #timer-display { font-size: 1.5em; font-weight: bold; color: #333; margin-top: 15px; text-align: center; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        @media (max-width: 900px) {
            body { padding: 0; justify-content: flex-start; }
            #game-screen { flex-direction: column; align-items: center; gap: 10px; padding: 10px 0; }
            #board-container { width: 95vw; height: 95vw; max-width: 500px; max-height: 500px; }
            #game-info { width: 95vw; max-width: 500px; }
        }
    </style>
</head>
<body>

    <div id="lobby">
        <h1>온라인 오목</h1>
        <input type="text" id="nickname" placeholder="닉네임을 입력하세요">
        <button id="create-room-btn">방 만들기 (친구와)</button>
        <button id="random-match-btn">랜덤 매치</button>
        <hr style="width:100%; margin: 20px 0;">
        <input type="text" id="room-id-input" placeholder="받은 방 ID(6자리 숫자) 입력">
        <button id="join-room-btn">방 참여하기</button>
    </div>

    <div id="game-screen" class="hidden">
        <div id="board-container">
            <canvas id="omok-board"></canvas>
        </div>
        <div id="game-info">
            <h2 id="room-id-display">방 ID: </h2>
            <div id="player1-info" class="player-info">
                <strong>흑돌:</strong> <span id="player1-name"></span>
            </div>
            <div id="player2-info" class="player-info">
                <strong>백돌:</strong> <span id="player2-name"></span>
            </div>
            <div id="status-message"></div>
            <div id="timer-display"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, get, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

        // Firebase 설정
        const firebaseConfig = {
            apiKey: "AIzaSyC4xAfGXIEggX-JHfLgP7Rg89kTpSR0P80",
            authDomain: "baseball-game-online.firebaseapp.com",
            databaseURL: "https://baseball-game-online-default-rtdb.firebaseio.com",
            projectId: "baseball-game-online",
            storageBucket: "baseball-game-online.firebasestorage.app",
            messagingSenderId: "780870375292",
            appId: "1:780870375292:web:3070374a4629225c4e76f9"
        };
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // --- DOM Elements ---
        const lobby = document.getElementById('lobby');
        const nicknameInput = document.getElementById('nickname');
        const createRoomBtn = document.getElementById('create-room-btn');
        const randomMatchBtn = document.getElementById('random-match-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        // (나머지 DOM 요소는 이전과 동일)
        const gameScreen = document.getElementById('game-screen');
        const roomIdInput = document.getElementById('room-id-input');
        const canvas = document.getElementById('omok-board');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const roomIdDisplay = document.getElementById('room-id-display');
        const player1Name = document.getElementById('player1-name');
        const player2Name = document.getElementById('player2-name');
        const player1Info = document.getElementById('player1-info');
        const player2Info = document.getElementById('player2-info');
        const timerDisplay = document.getElementById('timer-display');


        // --- Game Constants & State --- (이전과 동일)
        const BOARD_SIZE = 15;
        const TURN_TIME_SECONDS = 45;
        let currentRoomId = null;
        let myPlayerNumber = null;
        let roomUnsubscribe = null;
        let turnInterval = null;
        let lastKnownGameData = null;

        // --- Lobby Logic ---
        createRoomBtn.addEventListener('click', async () => {
            const nickname = nicknameInput.value.trim();
            if (!nickname) { alert('닉네임을 입력해주세요.'); return; }
            const roomId = (Math.floor(Math.random() * 900000) + 100000).toString();
            const roomRef = ref(database, `omok_rooms/${roomId}`);
            const initialGameState = {
                players: { 1: { nickname: nickname, ready: true } },
                board: createEmptyBoard(),
                currentPlayer: 1, gameState: 'waiting', winner: null
            };
            await set(roomRef, initialGameState);
            startGame(roomId, 1);
        });

        joinRoomBtn.addEventListener('click', () => {
            const nickname = nicknameInput.value.trim();
            if (!nickname) { alert('닉네임을 입력해주세요.'); return; }
            const roomId = roomIdInput.value.trim();
            if (!roomId) { alert('방 ID를 입력해주세요.'); return; }
            joinSpecificRoom(roomId, nickname);
        });

        randomMatchBtn.addEventListener('click', async () => {
            const nickname = nicknameInput.value.trim();
            if (!nickname) { alert('닉네임을 입력해주세요.'); return; }

            randomMatchBtn.disabled = true;
            randomMatchBtn.textContent = '상대 찾는 중...';

            const waitingPoolRef = ref(database, 'omok_waiting_pool');
            const snapshot = await get(waitingPoolRef);

            if (snapshot.exists()) {
                // --- Case 2: 대기자가 있음 -> 게임 참여 ---
                const waitingPlayer = snapshot.val();
                const waitingRoomId = waitingPlayer.roomId;

                // 대기 풀을 즉시 비워서 다른 사람이 못 들어오게 함
                await remove(waitingPoolRef);
                
                // 상대방의 방에 참여
                await joinSpecificRoom(waitingRoomId, nickname);

            } else {
                // --- Case 1: 대기자 없음 -> 새로운 방 만들고 대기 ---
                const newRoomId = (Math.floor(Math.random() * 900000) + 100000).toString();
                const newRoomRef = ref(database, `omok_rooms/${newRoomId}`);
                
                // 새로운 게임 방 생성
                const initialGameState = {
                    players: { 1: { nickname: nickname, ready: true } },
                    board: createEmptyBoard(),
                    currentPlayer: 1, gameState: 'waiting', winner: null
                };
                await set(newRoomRef, initialGameState);

                // 대기 풀에 내 정보 등록
                await set(waitingPoolRef, {
                    nickname: nickname,
                    roomId: newRoomId
                });

                // 내가 나갈 경우 대기풀에서 자동으로 삭제되도록 설정
                onDisconnect(waitingPoolRef).remove();

                // 게임 시작 (대기 상태로)
                startGame(newRoomId, 1);
            }
            randomMatchBtn.disabled = false;
            randomMatchBtn.textContent = '랜덤 매치';
        });

        async function joinSpecificRoom(roomId, nickname) {
            const roomRef = ref(database, `omok_rooms/${roomId}`);
            const snapshot = await get(roomRef);
            if (snapshot.exists()) {
                const roomData = snapshot.val();
                if (roomData.players && Object.keys(roomData.players).length < 2) {
                    const updatedData = { ...roomData,
                        players: { ...roomData.players, 2: { nickname: nickname, ready: true } },
                        gameState: 'playing'
                    };
                    await set(roomRef, updatedData);
                    startGame(roomId, 2);
                } else { alert('방이 꽉 찼거나 유효하지 않습니다.'); }
            } else { alert('방을 찾을 수 없습니다.'); }
        }

        // --- Game Setup ---
        function startGame(roomId, playerNumber) {
            currentRoomId = roomId;
            myPlayerNumber = playerNumber;
            lobby.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            roomIdDisplay.textContent = `방 ID: ${roomId}`;
            const roomRef = ref(database, `omok_rooms/${roomId}`);
            roomUnsubscribe = onValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    alert("방이 사라졌습니다. 로비로 돌아갑니다.");
                    window.location.reload();
                    return;
                }
                updateGame(snapshot.val());
            });
            canvas.addEventListener('click', handleBoardClick);
            window.addEventListener('resize', () => updateGame(null)); 
        }

        // --- 나머지 JavaScript 코드는 이전 버전과 완전히 동일합니다 ---
        // (updateGame, drawBoard, drawStones, handleBoardClick, placeStone, timer, rule checking 등)

        function createEmptyBoard() { return Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0)); }

        function updateGame(gameData) {
            if(gameData) { lastKnownGameData = gameData; } 
            else if (lastKnownGameData) { gameData = lastKnownGameData; } 
            else { return; }

            drawBoard();
            drawStones(gameData.board);

            player1Name.textContent = gameData.players[1]?.nickname || '대기 중...';
            player2Name.textContent = gameData.players[2]?.nickname || '대기 중...';
            player1Info.classList.remove('active');
            player2Info.classList.remove('active');

            if (gameData.gameState === 'playing') {
                if (gameData.currentPlayer === 1) player1Info.classList.add('active');
                else if(gameData.currentPlayer === 2) player2Info.classList.add('active');
                const currentPlayerName = gameData.players[gameData.currentPlayer].nickname;
                statusMessage.textContent = `${currentPlayerName} 님의 차례입니다.`;
                startTurnTimer(gameData.currentPlayer);
            } else {
                clearInterval(turnInterval);
                if (gameData.gameState === 'waiting') {
                    statusMessage.textContent = '상대방을 기다리고 있습니다...';
                    timerDisplay.textContent = "매칭 중";
                } else if (gameData.gameState === 'finished') {
                    const winnerName = gameData.players[gameData.winner].nickname;
                    statusMessage.textContent = `게임 종료! ${winnerName} 님의 승리입니다!`;
                    timerDisplay.textContent = "게임 종료";
                }
            }
        }

        function drawBoard() {
            canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight;
            const CELL_SIZE = canvas.width / BOARD_SIZE; const PADDING = CELL_SIZE / 2;
            ctx.fillStyle = '#e3b769'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#5c3d0d'; ctx.lineWidth = 1;
            for (let i = 0; i < BOARD_SIZE; i++) {
                ctx.beginPath(); ctx.moveTo(PADDING + i * CELL_SIZE, PADDING); ctx.lineTo(PADDING + i * CELL_SIZE, canvas.height - PADDING); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(PADDING, PADDING + i * CELL_SIZE); ctx.lineTo(canvas.width - PADDING, PADDING + i * CELL_SIZE); ctx.stroke();
            }
            const starPoints = [{x: 3, y: 3}, {x: 11, y: 3}, {x: 3, y: 11}, {x: 11, y: 11}, {x: 7, y: 7}];
            ctx.fillStyle = '#5c3d0d';
            starPoints.forEach(p => {
                ctx.beginPath(); ctx.arc(PADDING + p.x * CELL_SIZE, PADDING + p.y * CELL_SIZE, CELL_SIZE * 0.1, 0, 2 * Math.PI); ctx.fill();
            });
        }
        
        function drawStones(board) {
            if (!board) return;
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) { if (board[y][x] !== 0) drawStone(x, y, board[y][x]); }
            }
        }

        function drawStone(x, y, player) {
            const CELL_SIZE = canvas.width / BOARD_SIZE; const PADDING = CELL_SIZE / 2; const STONE_RADIUS = CELL_SIZE * 0.45;
            const canvasX = PADDING + x * CELL_SIZE; const canvasY = PADDING + y * CELL_SIZE;
            ctx.beginPath(); ctx.arc(canvasX, canvasY, STONE_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = (player === 1) ? 'black' : 'white'; ctx.fill();
        }

        async function handleBoardClick(event) {
            const roomRef = ref(database, `omok_rooms/${currentRoomId}`); const snapshot = await get(roomRef);
            if (!snapshot.exists()) return;
            const gameData = snapshot.val();
            if (gameData.gameState !== 'playing' || gameData.currentPlayer !== myPlayerNumber) return;
            const rect = canvas.getBoundingClientRect(); const mouseX = event.clientX - rect.left; const mouseY = event.clientY - rect.top;
            const CELL_SIZE = canvas.clientWidth / BOARD_SIZE; const PADDING = CELL_SIZE / 2;
            const x = Math.round((mouseX - PADDING) / CELL_SIZE); const y = Math.round((mouseY - PADDING) / CELL_SIZE);
            if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
            if (gameData.board[y][x] !== 0) { statusMessage.textContent = '이미 돌이 있는 곳입니다.'; return; }
            if (myPlayerNumber === 1 && isForbiddenMove(x, y, 1, gameData.board)) { statusMessage.textContent = '3-3 금지 위치입니다!'; return; }
            clearInterval(turnInterval);
            await placeStone(x, y, myPlayerNumber, gameData);
        }
        
        async function placeStone(x, y, player, currentGameData) {
            const newBoard = currentGameData.board.map(row => [...row]); newBoard[y][x] = player;
            const hasWon = checkWin(x, y, player, newBoard);
            const updatedData = { ...currentGameData, board: newBoard, currentPlayer: player === 1 ? 2 : 1 };
            if (hasWon) { updatedData.gameState = 'finished'; updatedData.winner = player; }
            const roomRef = ref(database, `omok_rooms/${currentRoomId}`);
            await set(roomRef, updatedData);
        }

        function startTurnTimer(currentPlayer) {
            clearInterval(turnInterval); let timeLeft = TURN_TIME_SECONDS;
            timerDisplay.textContent = `남은 시간: ${timeLeft}초`;
            turnInterval = setInterval(async () => {
                timeLeft--; timerDisplay.textContent = `남은 시간: ${timeLeft}초`;
                if (timeLeft < 0) {
                    clearInterval(turnInterval);
                    if (myPlayerNumber === currentPlayer) {
                        statusMessage.textContent = "시간 초과! 무작위 위치에 돌을 놓습니다.";
                        await makeRandomMove();
                    }
                }
            }, 1000);
        }
        
        async function makeRandomMove() {
            const roomRef = ref(database, `omok_rooms/${currentRoomId}`); const snapshot = await get(roomRef);
            if (!snapshot.exists()) return; const gameData = snapshot.val();
            if(gameData.currentPlayer !== myPlayerNumber) return;
            const emptySpots = [];
            for (let y = 0; y < BOARD_SIZE; y++) { for (let x = 0; x < BOARD_SIZE; x++) { if (gameData.board[y][x] === 0) emptySpots.push({ x, y }); }}
            if (emptySpots.length === 0) return;
            let validMoveFound = false;
            while (emptySpots.length > 0 && !validMoveFound) {
                const randomIndex = Math.floor(Math.random() * emptySpots.length); const { x, y } = emptySpots[randomIndex];
                if (myPlayerNumber === 1 && isForbiddenMove(x, y, 1, gameData.board)) { emptySpots.splice(randomIndex, 1); }
                else { await placeStone(x, y, myPlayerNumber, gameData); validMoveFound = true; }
            }
            if (!validMoveFound) {
                statusMessage.textContent = "착수할 유효한 위치가 없습니다! 턴을 넘깁니다.";
                const updatedData = { ...gameData, currentPlayer: myPlayerNumber === 1 ? 2 : 1 };
                await set(roomRef, updatedData);
            }
        }
        
        function checkWin(x, y, player, board) {
            const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }];
            for (const { dx, dy } of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) { const nx = x + i * dx, ny = y + i * dy; if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) count++; else break; }
                for (let i = 1; i < 5; i++) { const nx = x - i * dx, ny = y - i * dy; if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) count++; else break; }
                if (count >= 5) return true;
            }
            return false;
        }
        function isForbiddenMove(x, y, player, board) {
            if (player !== 1) return false;
            const tempBoard = board.map(row => [...row]); tempBoard[y][x] = player; let openThreeCount = 0;
            const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }];
            for (const { dx, dy } of directions) { if (createsOpenThree(x, y, player, tempBoard, dx, dy)) { openThreeCount++; } }
            return openThreeCount >= 2;
        }
        function createsOpenThree(x, y, player, board, dx, dy) {
            const patterns = [{ sequence: [player, 0, player, player, 0], checkIndex: 1 }, { sequence: [player, player, 0, player, 0], checkIndex: 2 },];
            for (let i = -4; i <= 0; i++) { if (checkPattern(x, y, player, board, dx, dy, i, [0, player, player, player, 0])) { const p1 = (i + 1), p2 = (i + 2), p3 = (i + 3); const placedOnX = (x === x + p1*dx && y === y + p1*dy) || (x === x + p2*dx && y === y + p2*dy) || (x === x + p3*dx && y === y + p3*dy); if(placedOnX) return true; }}
            for(const p of patterns) { for (let i = -4; i <= 0; i++) { if (checkPattern(x, y, player, board, dx, dy, i, p.sequence)) { const placedX = x + (i + p.checkIndex) * dx; const placedY = y + (i + p.checkIndex) * dy; if(x === placedX && y === placedY) return true; }}}
            return false;
        }
        function checkPattern(x, y, player, board, dx, dy, offset, pattern) {
            for (let i = 0; i < pattern.length; i++) {
                const nx = x + (i + offset) * dx; const ny = y + (i + offset) * dy;
                if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) return false;
                let boardVal = board[ny][nx]; let patternVal = pattern[i];
                if(patternVal === player && boardVal !== player) return false;
                if(patternVal === 0 && boardVal !== 0) return false;
            }
            return true;
        }
        window.addEventListener('beforeunload', () => { if (currentRoomId && roomUnsubscribe) { roomUnsubscribe(); } });

    </script>
</body>
</html>