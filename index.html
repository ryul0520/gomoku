<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>온라인 오목 게임</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; min-height: 100vh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f0f0; }
        body { display: flex; justify-content: center; align-items: center; flex-direction: column; padding: 10px; }
        .hidden { display: none !important; }
        #lobby { display: flex; flex-direction: column; padding: 30px; background-color: white; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); text-align: center; width: 95%; max-width: 400px; }
        #lobby h1 { margin-top: 0; }
        #lobby input { margin-bottom: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px; }
        #lobby button { padding: 10px 15px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; margin-top: 5px; transition: background-color 0.2s; }
        #create-room-btn { background-color: #007bff; color: white; }
        #random-match-btn { background-color: #28a745; color: white; margin-top: 10px; }
        #random-match-btn.matching { background-color: #dc3545; }
        #join-room-btn { background-color: #6c757d; color: white; }
        #game-screen { display: flex; gap: 20px; align-items: flex-start; justify-content: center; width: 100%; flex-wrap: wrap; }
        #board-container { position: relative; width: 600px; height: 600px; background-color: #e3b769; border: 2px solid #5c3d0d; flex-shrink: 0; }
        canvas { display: block; width: 100%; height: 100%; }
        #game-info { display: flex; flex-direction: column; width: 250px; padding: 20px; background-color: white; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        #game-info h2 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; font-size: 1.1em; word-break: break-all; }
        .player-info { margin: 10px 0; padding: 10px; border-radius: 5px; border: 2px solid transparent; }
        .player-info.active { border-color: #007bff; background-color: #e7f3ff; }
        #status-message { font-weight: bold; font-size: 1.15em; color: #d9534f; margin-top: 10px; min-height: 50px; }
        #timer-display { font-size: 1.5em; font-weight: bold; color: #333; margin-top: 15px; text-align: center; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        #action-btn { width: 100%; margin-top: 20px; padding: 15px 20px; font-size: 1.2em; font-weight: bold; }
        #action-btn:disabled { background-color: #6c757d; cursor: not-allowed; }
        #post-game-controls { margin-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        #post-game-controls button { width: 100%; padding: 10px; }
        #rematch-btn { background-color: #28a745; color: white; }
        #rematch-btn:disabled { background-color: #6c757d; cursor: not-allowed; }
        #end-game-btn { background-color: #dc3545; color: white; }
        #end-game-btn:hover { background-color: #c82333; }
        @media (max-width: 900px) {
            body { padding: 0; justify-content: flex-start; }
            #game-screen { flex-direction: column; align-items: center; gap: 10px; padding: 10px 0; }
            #board-container { width: 95vw; height: 95vw; max-width: 500px; max-height: 500px; }
            #game-info { width: 95vw; max-width: 500px; }
        }
    </style>
</head>
<body>

    <div id="lobby">
        <h1>온라인 오목</h1>
        <input type="text" id="nickname" placeholder="닉네임을 입력하세요">
        <button id="create-room-btn">방 만들기</button>
        <button id="random-match-btn">랜덤 매치</button>
        <hr style="width:100%; margin: 20px 0;">
        <input type="text" id="room-id-input" placeholder="받은 방 ID(6자리 숫자) 입력">
        <button id="join-room-btn">방 참여하기</button>
    </div>

    <div id="game-screen" class="hidden">
        <div id="board-container"><canvas id="omok-board"></canvas></div>
        <div id="game-info">
            <h2 id="room-id-display">방 ID: </h2>
            <div id="player1-info" class="player-info"><strong>흑돌:</strong> <span id="player1-name"></span></div>
            <div id="player2-info" class="player-info"><strong>백돌:</strong> <span id="player2-name"></span></div>
            <div id="status-message"></div>
            <div id="timer-display"></div>
            <button id="action-btn" class="hidden"></button>
            <div id="post-game-controls" class="hidden">
                <button id="rematch-btn">다시하기</button>
                <button id="end-game-btn">게임 종료</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, get, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

        // Firebase 설정 (이전과 동일)
        const firebaseConfig = { apiKey: "AIzaSyC4xAfGXIEggX-JHfLgP7Rg89kTpSR0P80", authDomain: "baseball-game-online.firebaseapp.com", databaseURL: "https://baseball-game-online-default-rtdb.firebaseio.com", projectId: "baseball-game-online", storageBucket: "baseball-game-online.firebasestorage.app", messagingSenderId: "780870375292", appId: "1:780870375292:web:3070374a4629225c4e76f9" };
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // --- DOM Elements --- (이전과 동일)
        const lobby = document.getElementById('lobby'), nicknameInput = document.getElementById('nickname'), createRoomBtn = document.getElementById('create-room-btn'), randomMatchBtn = document.getElementById('random-match-btn'), joinRoomBtn = document.getElementById('join-room-btn'), gameScreen = document.getElementById('game-screen'), roomIdInput = document.getElementById('room-id-input'), canvas = document.getElementById('omok-board'), ctx = canvas.getContext('2d'), statusMessage = document.getElementById('status-message'), roomIdDisplay = document.getElementById('room-id-display'), player1Name = document.getElementById('player1-name'), player2Name = document.getElementById('player2-name'), player1Info = document.getElementById('player1-info'), player2Info = document.getElementById('player2-info'), timerDisplay = document.getElementById('timer-display'), actionBtn = document.getElementById('action-btn'), postGameControls = document.getElementById('post-game-controls'), rematchBtn = document.getElementById('rematch-btn'), endGameBtn = document.getElementById('end-game-btn');
        
        // --- Game Constants & State --- (이전과 동일)
        const BOARD_SIZE = 15, TURN_TIME_SECONDS = 45;
        let currentRoomId = null, myPlayerNumber = null, roomUnsubscribe = null, turnInterval = null, lastKnownGameData = null;
        let isMatchmaking = false, myWaitingRoomId = null;

        // --- Lobby Logic (수정 없음) ---
        function createPlayerObject(nickname) { return { nickname: nickname, wantsRematch: false, connected: true }; }
        createRoomBtn.addEventListener('click', async () => { const nickname = nicknameInput.value.trim(); if (!nickname) { alert('닉네임을 입력해주세요.'); return; } const roomId = (Math.floor(Math.random() * 900000) + 100000).toString(); const roomRef = ref(database, `omok_rooms/${roomId}`); const initialGameState = { players: { 1: createPlayerObject(nickname) }, board: createEmptyBoard(), currentPlayer: 1, gameState: 'waiting', winner: null }; await set(roomRef, initialGameState); startGame(roomId, 1); });
        async function joinSpecificRoom(roomId, nickname) { const roomRef = ref(database, `omok_rooms/${roomId}`); const snapshot = await get(roomRef); if (snapshot.exists()) { const roomData = snapshot.val(); if (roomData.players && Object.keys(roomData.players).length < 2) { const updatedData = { ...roomData, players: { ...roomData.players, 2: createPlayerObject(nickname) }, gameState: 'playing' }; await set(roomRef, updatedData); isMatchmaking = false; startGame(roomId, 2); } else { alert('방이 꽉 찼거나 유효하지 않습니다.'); } } else { alert('방을 찾을 수 없습니다.'); } }
        randomMatchBtn.addEventListener('click', async () => { if (isMatchmaking) { await cancelMatchmaking(); } else { const nickname = nicknameInput.value.trim(); if (!nickname) { alert('닉네임을 입력해주세요.'); return; } isMatchmaking = true; randomMatchBtn.textContent = '매칭 취소'; randomMatchBtn.classList.add('matching'); const waitingPoolRef = ref(database, 'omok_waiting_pool'); const snapshot = await get(waitingPoolRef); if (snapshot.exists()) { const waitingRoomId = snapshot.val().roomId; await remove(waitingPoolRef); await joinSpecificRoom(waitingRoomId, nickname); } else { const newRoomId = (Math.floor(Math.random() * 900000) + 100000).toString(); myWaitingRoomId = newRoomId; const newRoomRef = ref(database, `omok_rooms/${newRoomId}`); const initialGameState = { players: { 1: createPlayerObject(nickname) }, board: createEmptyBoard(), currentPlayer: 1, gameState: 'waiting', winner: null }; await set(newRoomRef, initialGameState); await set(waitingPoolRef, { roomId: newRoomId }); onDisconnect(waitingPoolRef).remove(); startGame(newRoomId, 1); } } });
        async function cancelMatchmaking() { isMatchmaking = false; randomMatchBtn.textContent = '랜덤 매치'; randomMatchBtn.classList.remove('matching'); if (myWaitingRoomId) { await remove(ref(database, 'omok_waiting_pool')); await remove(ref(database, `omok_rooms/${myWaitingRoomId}`)); myWaitingRoomId = null; } alert('랜덤 매칭을 취소했습니다.'); window.location.reload(); }
        joinRoomBtn.addEventListener('click', () => { const nickname = nicknameInput.value.trim(); if (!nickname) { alert('닉네임을 입력해주세요.'); return; } const roomId = roomIdInput.value.trim(); if (!roomId) { alert('방 ID를 입력해주세요.'); return; } joinSpecificRoom(roomId, nickname); });

        // --- Game Setup (수정 없음) ---
        function startGame(roomId, playerNumber) { currentRoomId = roomId; myPlayerNumber = playerNumber; lobby.classList.add('hidden'); gameScreen.classList.remove('hidden'); roomIdDisplay.textContent = `방 ID: ${roomId}`; const myPlayerConnectionRef = ref(database, `omok_rooms/${currentRoomId}/players/${myPlayerNumber}/connected`); onDisconnect(myPlayerConnectionRef).set(false); const roomRef = ref(database, `omok_rooms/${roomId}`); roomUnsubscribe = onValue(roomRef, (snapshot) => { if (!snapshot.exists()) { if (!gameScreen.classList.contains('hidden')) { alert("방이 사라졌습니다. 로비로 돌아갑니다."); window.location.reload(); } return; } updateGame(snapshot.val()); }); canvas.addEventListener('click', handleBoardClick); window.addEventListener('resize', () => updateGame(null)); actionBtn.addEventListener('click', handleActionBtnClick); rematchBtn.addEventListener('click', handleRematch); endGameBtn.addEventListener('click', handleEndGame); }

        // --- Game Update (수정 없음) ---
        function updateGame(gameData) {
            if (gameData) { lastKnownGameData = gameData; } else if (lastKnownGameData) { gameData = lastKnownGameData; } else { return; }
            drawBoard(); drawStones(gameData.board);
            player1Name.textContent = gameData.players[1]?.nickname || '대기 중...'; player2Name.textContent = gameData.players[2]?.nickname || '대기 중...';
            player1Info.classList.remove('active'); player2Info.classList.remove('active');
            actionBtn.classList.add('hidden'); postGameControls.classList.add('hidden'); clearInterval(turnInterval);

            if (gameData.gameState === 'playing') {
                isMatchmaking = false; randomMatchBtn.textContent = '랜덤 매치'; randomMatchBtn.classList.remove('matching');
                actionBtn.classList.remove('hidden'); actionBtn.textContent = '항복하기'; actionBtn.style.backgroundColor = '#dc3545';
                if (gameData.currentPlayer === 1) player1Info.classList.add('active'); else if (gameData.currentPlayer === 2) player2Info.classList.add('active');
                statusMessage.textContent = `${gameData.players[gameData.currentPlayer].nickname} 님의 차례입니다.`;
                startTurnTimer(gameData.currentPlayer);
            } else if (gameData.gameState === 'waiting') {
                actionBtn.classList.remove('hidden'); actionBtn.textContent = '로비로 돌아가기'; actionBtn.style.backgroundColor = '#dc3545';
                statusMessage.textContent = '상대방을 기다리고 있습니다...'; timerDisplay.textContent = "매칭 대기중";
            } else if (gameData.gameState === 'finished') {
                postGameControls.classList.remove('hidden'); const winnerName = gameData.players[gameData.winner].nickname;
                if (gameData.surrendered) {
                    const loserNumber = gameData.winner === 1 ? 2 : 1;
                    statusMessage.textContent = `${gameData.players[loserNumber].nickname} 님이 항복하여 ${winnerName} 님의 승리입니다!`;
                } else { statusMessage.textContent = `게임 종료! ${winnerName} 님의 승리입니다!`; }
                timerDisplay.textContent = "게임 종료"; updateRematchButton(gameData);
            }
        }
        
        // --- 버튼 핸들러 (수정 없음) ---
        async function handleActionBtnClick() { const gameData = lastKnownGameData; if (!gameData) return; if (gameData.gameState === 'playing') { if (!confirm("정말로 항복하시겠습니까?")) return; const winnerNumber = myPlayerNumber === 1 ? 2 : 1; const updatedData = { ...gameData, gameState: 'finished', winner: winnerNumber, surrendered: true }; await set(ref(database, `omok_rooms/${currentRoomId}`), updatedData); } else if (gameData.gameState === 'waiting') { if (!confirm("방을 삭제하고 로비로 돌아가시겠습니까?")) return; if (myWaitingRoomId && myWaitingRoomId === currentRoomId) { await remove(ref(database, 'omok_waiting_pool')); } await remove(ref(database, `omok_rooms/${currentRoomId}`)); window.location.reload(); } }
        
        // --- 이하 로직 중 handleBoardClick 함수만 수정됩니다 ---
        function updateRematchButton(gameData) { const opponentPlayerNumber = myPlayerNumber === 1 ? 2 : 1; const opponent = gameData.players[opponentPlayerNumber]; if (!opponent || opponent.connected === false) { rematchBtn.textContent = "상대방이 나갔습니다"; rematchBtn.disabled = true; return; } const myStatus = gameData.players[myPlayerNumber].wantsRematch; const opponentStatus = opponent.wantsRematch; if (myStatus) { rematchBtn.textContent = "재대결 요청함 (대기중)"; rematchBtn.disabled = true; } else if (opponentStatus) { rematchBtn.textContent = "상대방이 재대결 요청! (수락)"; rematchBtn.disabled = false; } else { rematchBtn.textContent = "다시하기"; rematchBtn.disabled = false; } }
        async function handleRematch() { const roomRef = ref(database, `omok_rooms/${currentRoomId}`); const snapshot = await get(roomRef); if (!snapshot.exists()) return; const gameData = snapshot.val(); const opponentPlayerNumber = myPlayerNumber === 1 ? 2 : 1; if (gameData.players[opponentPlayerNumber]?.wantsRematch) { const newGameData = { ...gameData, board: createEmptyBoard(), currentPlayer: 1, gameState: 'playing', winner: null, surrendered: false, players: { 1: { ...gameData.players[1], wantsRematch: false, connected: true }, 2: { ...gameData.players[2], wantsRematch: false, connected: true } } }; await set(roomRef, newGameData); } else { const myPlayerRef = ref(database, `omok_rooms/${currentRoomId}/players/${myPlayerNumber}/wantsRematch`); await set(myPlayerRef, true); } }
        async function handleEndGame() { const roomRef = ref(database, `omok_rooms/${currentRoomId}`); await remove(roomRef); window.location.reload(); }
        function createEmptyBoard() { return Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0)); }
        function drawBoard() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; const CELL_SIZE = canvas.width / BOARD_SIZE; const PADDING = CELL_SIZE / 2; ctx.fillStyle = '#e3b769'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = '#5c3d0d'; ctx.lineWidth = 1; for (let i = 0; i < BOARD_SIZE; i++) { ctx.beginPath(); ctx.moveTo(PADDING + i * CELL_SIZE, PADDING); ctx.lineTo(PADDING + i * CELL_SIZE, canvas.height - PADDING); ctx.stroke(); ctx.beginPath(); ctx.moveTo(PADDING, PADDING + i * CELL_SIZE); ctx.lineTo(canvas.width - PADDING, PADDING + i * CELL_SIZE); ctx.stroke(); } const starPoints = [{x: 3, y: 3}, {x: 11, y: 3}, {x: 3, y: 11}, {x: 11, y: 11}, {x: 7, y: 7}]; ctx.fillStyle = '#5c3d0d'; starPoints.forEach(p => { ctx.beginPath(); ctx.arc(PADDING + p.x * CELL_SIZE, PADDING + p.y * CELL_SIZE, CELL_SIZE * 0.1, 0, 2 * Math.PI); ctx.fill(); }); }
        function drawStones(board) { if (!board) return; for (let y = 0; y < BOARD_SIZE; y++) { for (let x = 0; x < BOARD_SIZE; x++) { if (board[y][x] !== 0) drawStone(x, y, board[y][x]); } } }
        function drawStone(x, y, player) { const CELL_SIZE = canvas.width / BOARD_SIZE; const PADDING = CELL_SIZE / 2; const STONE_RADIUS = CELL_SIZE * 0.45; const canvasX = PADDING + x * CELL_SIZE; const canvasY = PADDING + y * CELL_SIZE; ctx.beginPath(); ctx.arc(canvasX, canvasY, STONE_RADIUS, 0, 2 * Math.PI); ctx.fillStyle = (player === 1) ? 'black' : 'white'; ctx.fill(); }
        
        async function handleBoardClick(event) {
            const roomRef = ref(database, `omok_rooms/${currentRoomId}`);
            const snapshot = await get(roomRef);
            if (!snapshot.exists()) return;
            const gameData = snapshot.val();
            if (gameData.gameState !== 'playing' || gameData.currentPlayer !== myPlayerNumber) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const CELL_SIZE = canvas.clientWidth / BOARD_SIZE;
            const PADDING = CELL_SIZE / 2;
            const x = Math.round((mouseX - PADDING) / CELL_SIZE);
            const y = Math.round((mouseY - PADDING) / CELL_SIZE);
            if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
            if (gameData.board[y][x] !== 0) {
                statusMessage.textContent = '이미 돌이 있는 곳입니다.';
                return;
            }
            if (myPlayerNumber === 1 && isForbiddenMove(x, y, 1, gameData.board)) {
                statusMessage.textContent = '3-3 금지 위치입니다!'; // <--- 수정된 부분
                return;
            }
            clearInterval(turnInterval);
            await placeStone(x, y, myPlayerNumber, gameData);
        }

        async function placeStone(x, y, player, currentGameData) { const newBoard = currentGameData.board.map(row => [...row]); newBoard[y][x] = player; const hasWon = checkWin(x, y, player, newBoard); const updatedData = { ...currentGameData, board: newBoard, currentPlayer: player === 1 ? 2 : 1 }; if (hasWon) { updatedData.gameState = 'finished'; updatedData.winner = player; } const roomRef = ref(database, `omok_rooms/${currentRoomId}`); await set(roomRef, updatedData); }
        function startTurnTimer(currentPlayer) { clearInterval(turnInterval); let timeLeft = TURN_TIME_SECONDS; timerDisplay.textContent = `남은 시간: ${timeLeft}초`; turnInterval = setInterval(async () => { timeLeft--; timerDisplay.textContent = `남은 시간: ${timeLeft}초`; if (timeLeft < 0) { clearInterval(turnInterval); if (myPlayerNumber === currentPlayer) { statusMessage.textContent = "시간 초과! 무작위 위치에 돌을 놓습니다."; await makeRandomMove(); } } }, 1000); }
        async function makeRandomMove() { const roomRef = ref(database, `omok_rooms/${currentRoomId}`); const snapshot = await get(roomRef); if (!snapshot.exists()) return; const gameData = snapshot.val(); if(gameData.currentPlayer !== myPlayerNumber) return; const emptySpots = []; for (let y = 0; y < BOARD_SIZE; y++) { for (let x = 0; x < BOARD_SIZE; x++) { if (gameData.board[y][x] === 0) emptySpots.push({ x, y }); }} if (emptySpots.length === 0) return; let validMoveFound = false; while (emptySpots.length > 0 && !validMoveFound) { const randomIndex = Math.floor(Math.random() * emptySpots.length); const { x, y } = emptySpots[randomIndex]; if (myPlayerNumber === 1 && isForbiddenMove(x, y, 1, gameData.board)) { emptySpots.splice(randomIndex, 1); } else { await placeStone(x, y, myPlayerNumber, gameData); validMoveFound = true; } } if (!validMoveFound) { statusMessage.textContent = "착수할 유효한 위치가 없습니다! 턴을 넘깁니다."; const updatedData = { ...gameData, currentPlayer: myPlayerNumber === 1 ? 2 : 1 }; await set(roomRef, updatedData); } }
        function checkWin(x, y, player, board) { const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }]; for (const { dx, dy } of directions) { let count = 1; for (let i = 1; i < 5; i++) { const nx = x + i * dx, ny = y + i * dy; if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) count++; else break; } for (let i = 1; i < 5; i++) { const nx = x - i * dx, ny = y - i * dy; if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[ny][nx] === player) count++; else break; } if (count >= 5) return true; } return false; }
        function isForbiddenMove(x, y, player, board) { if (player !== 1) return false; const tempBoard = board.map(row => [...row]); tempBoard[y][x] = player; let openThreeCount = 0; const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }]; for (const { dx, dy } of directions) { if (createsOpenThree(x, y, player, tempBoard, dx, dy)) { openThreeCount++; } } return openThreeCount >= 2; }
        function createsOpenThree(x, y, player, board, dx, dy) { const patterns = [{ sequence: [player, 0, player, player, 0], checkIndex: 1 }, { sequence: [player, player, 0, player, 0], checkIndex: 2 },]; for (let i = -4; i <= 0; i++) { if (checkPattern(x, y, player, board, dx, dy, i, [0, player, player, player, 0])) { const p1 = (i + 1), p2 = (i + 2), p3 = (i + 3); const placedOnX = (x === x + p1*dx && y === y + p1*dy) || (x === x + p2*dx && y === y + p2*dy) || (x === x + p3*dx && y === y + p3*dy); if(placedOnX) return true; }} for(const p of patterns) { for (let i = -4; i <= 0; i++) { if (checkPattern(x, y, player, board, dx, dy, i, p.sequence)) { const placedX = x + (i + p.checkIndex) * dx; const placedY = y + (i + p.checkIndex) * dy; if(x === placedX && y === placedY) return true; }}} return false; }
        function checkPattern(x, y, player, board, dx, dy, offset, pattern) { for (let i = 0; i < pattern.length; i++) { const nx = x + (i + offset) * dx; const ny = y + (i + offset) * dy; if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) return false; let boardVal = board[ny][nx]; let patternVal = pattern[i]; if(patternVal === player && boardVal !== player) return false; if(patternVal === 0 && boardVal !== 0) return false; } return true; }
        window.addEventListener('beforeunload', () => { if (currentRoomId && roomUnsubscribe) { roomUnsubscribe(); } });
    </script>
</body>
</html>