<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>온라인 오목 게임 (렌주룰)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; min-height: 100vh; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f0f0; }
        body { display: flex; justify-content: center; align-items: center; flex-direction: column; padding: 10px; }
        .hidden { display: none !important; }
        #lobby { display: flex; flex-direction: column; padding: 30px; background-color: white; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); text-align: center; width: 95%; max-width: 400px; }
        #lobby h1 { margin-top: 0; }
        #lobby input { margin-bottom: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px; }
        #lobby button { padding: 10px 15px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; margin-top: 5px; transition: background-color 0.2s; }
        #create-room-btn { background-color: #007bff; color: white; }
        #random-match-btn { background-color: #28a745; color: white; margin-top: 10px; }
        #random-match-btn.matching { background-color: #dc3545; }
        #join-room-btn { background-color: #6c757d; color: white; }
        #game-screen { display: flex; gap: 20px; align-items: flex-start; justify-content: center; width: 100%; flex-wrap: wrap; }
        #board-container { position: relative; width: 600px; height: 600px; background-color: #e3b769; border: 2px solid #5c3d0d; flex-shrink: 0; }
        canvas { display: block; width: 100%; height: 100%; }
        #game-info { display: flex; flex-direction: column; width: 250px; padding: 20px; background-color: white; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        #game-info h2 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; font-size: 1.1em; word-break: break-all; }
        .player-info { margin: 10px 0; padding: 10px; border-radius: 5px; border: 2px solid transparent; }
        .player-info.active { border-color: #007bff; background-color: #e7f3ff; }
        #status-message { font-weight: bold; font-size: 1.15em; color: #d9534f; margin-top: 10px; min-height: 50px; }
        #timer-display { font-size: 1.5em; font-weight: bold; color: #333; margin-top: 15px; text-align: center; padding: 10px; background: #f8f9fa; border-radius: 5px; }
        #action-btn { width: 100%; margin-top: 20px; padding: 15px 20px; font-size: 1.2em; font-weight: bold; }
        #action-btn:disabled { background-color: #6c757d; cursor: not-allowed; }
        #post-game-controls { margin-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        #post-game-controls button { width: 100%; padding: 10px; }
        #rematch-btn { background-color: #28a745; color: white; }
        #rematch-btn:disabled { background-color: #6c757d; cursor: not-allowed; }
        #end-game-btn { background-color: #dc3545; color: white; }
        #end-game-btn:hover { background-color: #c82333; }
        @media (max-width: 900px) {
            body { padding: 0; justify-content: flex-start; }
            #game-screen { flex-direction: column; align-items: center; gap: 10px; padding: 10px 0; }
            #board-container { width: 95vw; height: 95vw; max-width: 500px; max-height: 500px; }
            #game-info { width: 95vw; max-width: 500px; }
        }
    </style>
</head>
<body>

    <div id="lobby">
        <h1>온라인 오목 (렌주룰)</h1>
        <input type="text" id="nickname" placeholder="닉네임을 입력하세요">
        <button id="create-room-btn">방 만들기</button>
        <button id="random-match-btn">랜덤 매치</button>
        <hr style="width:100%; margin: 20px 0;">
        <input type="text" id="room-id-input" placeholder="받은 방 ID(6자리 숫자) 입력">
        <button id="join-room-btn">방 참여하기</button>
    </div>

    <div id="game-screen" class="hidden">
        <div id="board-container"><canvas id="omok-board"></canvas></div>
        <div id="game-info">
            <h2 id="room-id-display">방 ID: </h2>
            <div id="player1-info" class="player-info"><strong>흑돌:</strong> <span id="player1-name"></span></div>
            <div id="player2-info" class="player-info"><strong>백돌:</strong> <span id="player2-name"></span></div>
            <div id="status-message"></div>
            <div id="timer-display"></div>
            <button id="action-btn" class="hidden"></button>
            <div id="post-game-controls" class="hidden">
                <button id="rematch-btn">다시하기</button>
                <button id="end-game-btn">게임 종료</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, get, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

        const firebaseConfig = { apiKey: "AIzaSyC4xAfGXIEggX-JHfLgP7Rg89kTpSR0P80", authDomain: "baseball-game-online.firebaseapp.com", databaseURL: "https://baseball-game-online-default-rtdb.firebaseio.com", projectId: "baseball-game-online", storageBucket: "baseball-game-online.firebasestorage.app", messagingSenderId: "780870375292", appId: "1:780870375292:web:3070374a4629225c4e76f9" };
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        const lobby = document.getElementById('lobby'), nicknameInput = document.getElementById('nickname'), createRoomBtn = document.getElementById('create-room-btn'), randomMatchBtn = document.getElementById('random-match-btn'), joinRoomBtn = document.getElementById('join-room-btn'), gameScreen = document.getElementById('game-screen'), roomIdInput = document.getElementById('room-id-input'), canvas = document.getElementById('omok-board'), ctx = canvas.getContext('2d'), statusMessage = document.getElementById('status-message'), roomIdDisplay = document.getElementById('room-id-display'), player1Name = document.getElementById('player1-name'), player2Name = document.getElementById('player2-name'), player1Info = document.getElementById('player1-info'), player2Info = document.getElementById('player2-info'), timerDisplay = document.getElementById('timer-display'), actionBtn = document.getElementById('action-btn'), postGameControls = document.getElementById('post-game-controls'), rematchBtn = document.getElementById('rematch-btn'), endGameBtn = document.getElementById('end-game-btn');

        const BOARD_SIZE = 15, TURN_TIME_SECONDS = 45;
        let currentRoomId = null, myPlayerNumber = null, roomUnsubscribe = null, turnInterval = null, lastKnownGameData = null;
        let isMatchmaking = false, myWaitingRoomId = null;

        function createPlayerObject(nickname) { return { nickname: nickname, wantsRematch: false, connected: true }; }
        createRoomBtn.addEventListener('click', async () => { const nickname = nicknameInput.value.trim(); if (!nickname) { alert('닉네임을 입력해주세요.'); return; } const roomId = (Math.floor(Math.random() * 900000) + 100000).toString(); const roomRef = ref(database, `omok_rooms/${roomId}`); const initialGameState = { players: { 1: createPlayerObject(nickname) }, board: createEmptyBoard(), currentPlayer: 1, gameState: 'waiting', winner: null }; await set(roomRef, initialGameState); startGame(roomId, 1); });
        async function joinSpecificRoom(roomId, nickname) { const roomRef = ref(database, `omok_rooms/${roomId}`); const snapshot = await get(roomRef); if (snapshot.exists()) { const roomData = snapshot.val(); if (roomData.players && Object.keys(roomData.players).length < 2) { const joinerPlayerObject = createPlayerObject(nickname); const creatorPlayerObject = roomData.players[1]; let finalPlayers; let myAssignedNumber; if (Math.random() < 0.5) { finalPlayers = { 1: joinerPlayerObject, 2: creatorPlayerObject }; myAssignedNumber = 1; } else { finalPlayers = { 1: creatorPlayerObject, 2: joinerPlayerObject }; myAssignedNumber = 2; } const updatedData = { ...roomData, players: finalPlayers, gameState: 'playing' }; await set(roomRef, updatedData); isMatchmaking = false; startGame(roomId, myAssignedNumber); } else { alert('방이 꽉 찼거나 유효하지 않습니다.'); } } else { alert('방을 찾을 수 없습니다.'); } }
        randomMatchBtn.addEventListener('click', async () => { if (isMatchmaking) { await cancelMatchmaking(); } else { const nickname = nicknameInput.value.trim(); if (!nickname) { alert('닉네임을 입력해주세요.'); return; } isMatchmaking = true; randomMatchBtn.textContent = '매칭 취소'; randomMatchBtn.classList.add('matching'); const waitingPoolRef = ref(database, 'omok_waiting_pool'); const snapshot = await get(waitingPoolRef); if (snapshot.exists()) { const waitingRoomId = snapshot.val().roomId; await remove(waitingPoolRef); await joinSpecificRoom(waitingRoomId, nickname); } else { const newRoomId = (Math.floor(Math.random() * 900000) + 100000).toString(); myWaitingRoomId = newRoomId; const newRoomRef = ref(database, `omok_rooms/${newRoomId}`); const initialGameState = { players: { 1: createPlayerObject(nickname) }, board: createEmptyBoard(), currentPlayer: 1, gameState: 'waiting', winner: null }; await set(newRoomRef, initialGameState); await set(waitingPoolRef, { roomId: newRoomId }); onDisconnect(waitingPoolRef).remove(); startGame(newRoomId, 1); } } });
        async function cancelMatchmaking() { isMatchmaking = false; randomMatchBtn.textContent = '랜덤 매치'; randomMatchBtn.classList.remove('matching'); if (myWaitingRoomId) { await remove(ref(database, 'omok_waiting_pool')); await remove(ref(database, `omok_rooms/${myWaitingRoomId}`)); myWaitingRoomId = null; } alert('랜덤 매칭을 취소했습니다.'); window.location.reload(); }
        joinRoomBtn.addEventListener('click', () => { const nickname = nicknameInput.value.trim(); if (!nickname) { alert('닉네임을 입력해주세요.'); return; } const roomId = roomIdInput.value.trim(); if (!roomId) { alert('방 ID를 입력해주세요.'); return; } joinSpecificRoom(roomId, nickname); });
        function startGame(roomId, playerNumber) { currentRoomId = roomId; myPlayerNumber = playerNumber; lobby.classList.add('hidden'); gameScreen.classList.remove('hidden'); roomIdDisplay.textContent = `방 ID: ${roomId}`; const roomRef = ref(database, `omok_rooms/${roomId}`); roomUnsubscribe = onValue(roomRef, (snapshot) => { if (!snapshot.exists()) { if (!gameScreen.classList.contains('hidden')) { alert("방이 사라졌습니다. 로비로 돌아갑니다."); window.location.reload(); } return; } updateGame(snapshot.val()); }); const myPlayerConnectionRef = ref(database, `omok_rooms/${currentRoomId}/players/${playerNumber}/connected`); onDisconnect(myPlayerConnectionRef).set(false).catch(()=>{}); canvas.addEventListener('click', handleBoardClick); window.addEventListener('resize', () => drawBoard()); actionBtn.addEventListener('click', handleActionBtnClick); rematchBtn.addEventListener('click', handleRematch); endGameBtn.addEventListener('click', handleEndGame); }
        
        // --- ▼▼▼ 수정된 함수 ▼▼▼ ---
        function updateGame(gameData) {
            // 게임 시작 또는 재시작 시, 자신의 플레이어 번호(흑/백)를 다시 확인
            if ((lastKnownGameData?.gameState === 'waiting' || lastKnownGameData?.gameState === 'finished') && gameData.gameState === 'playing') {
                const myNickname = nicknameInput.value.trim();
                if (gameData.players[1]?.nickname === myNickname) { myPlayerNumber = 1; } 
                else if (gameData.players[2]?.nickname === myNickname) { myPlayerNumber = 2; }
            }

            if (gameData) { lastKnownGameData = gameData; } else if (lastKnownGameData) { gameData = lastKnownGameData; } else { return; }
            drawBoard();
            player1Name.textContent = gameData.players[1]?.nickname || '대기 중...';
            player2Name.textContent = gameData.players[2]?.nickname || '대기 중...';
            player1Info.classList.remove('active'); player2Info.classList.remove('active');
            actionBtn.classList.add('hidden'); postGameControls.classList.add('hidden');
            if (gameData.gameState !== 'playing') clearInterval(turnInterval);

            if (gameData.gameState === 'playing') {
                isMatchmaking = false; randomMatchBtn.textContent = '랜덤 매치'; randomMatchBtn.classList.remove('matching');
                actionBtn.classList.remove('hidden'); actionBtn.textContent = '항복하기'; actionBtn.style.backgroundColor = '#dc3545';
                if (gameData.currentPlayer === 1) player1Info.classList.add('active'); else if (gameData.currentPlayer === 2) player2Info.classList.add('active');
                if (gameData.currentPlayer !== lastKnownGameData?.currentPlayer) {
                    startTurnTimer(gameData.currentPlayer);
                }
                statusMessage.textContent = `${gameData.players[gameData.currentPlayer].nickname} 님의 차례입니다.`;
            } else if (gameData.gameState === 'waiting') {
                actionBtn.classList.remove('hidden'); actionBtn.textContent = '로비로 돌아가기'; actionBtn.style.backgroundColor = '#dc3545';
                statusMessage.textContent = '상대방을 기다리고 있습니다...'; timerDisplay.textContent = "매칭 대기중";
            } else if (gameData.gameState === 'finished') {
                clearInterval(turnInterval);
                postGameControls.classList.remove('hidden'); const winnerName = gameData.players[gameData.winner].nickname;
                if (gameData.surrendered) {
                    const loserNumber = gameData.winner === 1 ? 2 : 1;
                    statusMessage.textContent = `${gameData.players[loserNumber].nickname} 님이 항복하여 ${winnerName} 님의 승리입니다!`;
                } else { statusMessage.textContent = `게임 종료! ${winnerName} 님의 승리입니다!`; }
                timerDisplay.textContent = "게임 종료"; updateRematchButton(gameData);
            }
        }
        
        async function handleActionBtnClick() { const gameData = lastKnownGameData; if (!gameData) return; if (gameData.gameState === 'playing') { if (!confirm("정말로 항복하시겠습니까?")) return; const winnerNumber = myPlayerNumber === 1 ? 2 : 1; const updatedData = { ...gameData, gameState: 'finished', winner: winnerNumber, surrendered: true }; await set(ref(database, `omok_rooms/${currentRoomId}`), updatedData); } else if (gameData.gameState === 'waiting') { if (!confirm("방을 삭제하고 로비로 돌아가시겠습니까?")) return; if (myWaitingRoomId && myWaitingRoomId === currentRoomId) { await remove(ref(database, 'omok_waiting_pool')); } await remove(ref(database, `omok_rooms/${currentRoomId}`)); window.location.reload(); } }
        function updateRematchButton(gameData) { const opponentPlayerNumber = myPlayerNumber === 1 ? 2 : 1; const opponent = gameData.players[opponentPlayerNumber]; if (!opponent || opponent.connected === false) { rematchBtn.textContent = "상대방이 나갔습니다"; rematchBtn.disabled = true; return; } const myStatus = gameData.players[myPlayerNumber]?.wantsRematch; const opponentStatus = opponent?.wantsRematch; if (myStatus) { rematchBtn.textContent = "재대결 요청함 (대기중)"; rematchBtn.disabled = true; } else if (opponentStatus) { rematchBtn.textContent = "상대방이 재대결 요청! (수락)"; rematchBtn.disabled = false; } else { rematchBtn.textContent = "다시하기"; rematchBtn.disabled = false; } }
        
        // --- ▼▼▼ 수정된 함수 ▼▼▼ ---
        async function handleRematch() {
            const roomRef = ref(database, `omok_rooms/${currentRoomId}`);
            const snapshot = await get(roomRef);
            if (!snapshot.exists()) return;
            const gameData = snapshot.val();
            const opponentPlayerNumber = myPlayerNumber === 1 ? 2 : 1;
            
            if (gameData.players[opponentPlayerNumber]?.wantsRematch) {
                // 재대결 수락: 게임 상태 초기화 및 흑/백 랜덤 재배정
                const p1 = gameData.players[1];
                const p2 = gameData.players[2];
                // 닉네임은 그대로 두고, 흑/백 역할만 바꿈
                const newPlayers = (Math.random() < 0.5) ? 
                    { 1: { ...p2, wantsRematch: false }, 2: { ...p1, wantsRematch: false } } : 
                    { 1: { ...p1, wantsRematch: false }, 2: { ...p2, wantsRematch: false } };
                
                const newGameData = { ...gameData, board: createEmptyBoard(), currentPlayer: 1, gameState: 'playing', winner: null, surrendered: false, players: newPlayers };
                await set(roomRef, newGameData);
            } else {
                // 재대결 요청
                const myPlayerRef = ref(database, `omok_rooms/${currentRoomId}/players/${myPlayerNumber}/wantsRematch`);
                await set(myPlayerRef, true);
            }
        }
        
        async function handleEndGame() { if (currentRoomId) { await remove(ref(database, `omok_rooms/${currentRoomId}`)); } window.location.reload(); }
        function createEmptyBoard() { return Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0)); }
        function drawBoard() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; const CELL_SIZE = canvas.width / BOARD_SIZE; const PADDING = CELL_SIZE / 2; ctx.fillStyle = '#e3b769'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = '#5c3d0d'; ctx.lineWidth = 1; for (let i = 0; i < BOARD_SIZE; i++) { ctx.beginPath(); ctx.moveTo(PADDING + i * CELL_SIZE, PADDING); ctx.lineTo(PADDING + i * CELL_SIZE, canvas.height - PADDING); ctx.stroke(); ctx.beginPath(); ctx.moveTo(PADDING, PADDING + i * CELL_SIZE); ctx.lineTo(canvas.width - PADDING, PADDING + i * CELL_SIZE); ctx.stroke(); } const starPoints = [{x: 3, y: 3}, {x: 11, y: 3}, {x: 3, y: 11}, {x: 11, y: 11}, {x: 7, y: 7}]; ctx.fillStyle = '#5c3d0d'; starPoints.forEach(p => { ctx.beginPath(); ctx.arc(PADDING + p.x * CELL_SIZE, PADDING + p.y * CELL_SIZE, CELL_SIZE * 0.1, 0, 2 * Math.PI); ctx.fill(); }); if(lastKnownGameData?.board) drawStones(lastKnownGameData.board); }
        function drawStones(board) { for (let y = 0; y < BOARD_SIZE; y++) { for (let x = 0; x < BOARD_SIZE; x++) { if (board[y][x] !== 0) drawStone(x, y, board[y][x]); } } }
        function drawStone(x, y, player) { const CELL_SIZE = canvas.width / BOARD_SIZE; const PADDING = CELL_SIZE / 2; const STONE_RADIUS = CELL_SIZE * 0.45; const canvasX = PADDING + x * CELL_SIZE; const canvasY = PADDING + y * CELL_SIZE; ctx.beginPath(); ctx.arc(canvasX, canvasY, STONE_RADIUS, 0, 2 * Math.PI); ctx.fillStyle = (player === 1) ? 'black' : 'white'; ctx.fill(); }
        
        async function handleBoardClick(event) {
            if (!lastKnownGameData) return;
            const { gameState, currentPlayer, board } = lastKnownGameData;
            if (gameState !== 'playing' || currentPlayer !== myPlayerNumber) return;
            const rect = canvas.getBoundingClientRect();
            const CELL_SIZE = canvas.clientWidth / BOARD_SIZE;
            const PADDING = CELL_SIZE / 2;
            const x = Math.round((event.clientX - rect.left - PADDING) / CELL_SIZE);
            const y = Math.round((event.clientY - rect.top - PADDING) / CELL_SIZE);
            if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE || board[y][x] !== 0) return;
            if (myPlayerNumber === 1) {
                const forbiddenReason = isForbiddenMove(x, y, board);
                if (forbiddenReason) {
                    statusMessage.textContent = `금수(${forbiddenReason}) 위치입니다!`;
                    return;
                }
            }
            clearInterval(turnInterval);
            await placeStone(x, y, myPlayerNumber, lastKnownGameData);
        }

        async function placeStone(x, y, player, currentGameData) { const newBoard = currentGameData.board.map(row => [...row]); newBoard[y][x] = player; const hasWon = checkWin(x, y, player, newBoard); const updatedData = { ...currentGameData, board: newBoard, currentPlayer: player === 1 ? 2 : 1 }; if (hasWon) { updatedData.gameState = 'finished'; updatedData.winner = player; } const roomRef = ref(database, `omok_rooms/${currentRoomId}`); await set(roomRef, updatedData); }
        
        function startTurnTimer(currentPlayer) {
            clearInterval(turnInterval);
            let timeLeft = TURN_TIME_SECONDS;
            timerDisplay.textContent = `남은 시간: ${timeLeft}초`;
            turnInterval = setInterval(async () => {
                timeLeft--;
                if (timeLeft < 0) {
                    clearInterval(turnInterval);
                    timerDisplay.textContent = "시간 초과!";
                    if (myPlayerNumber === currentPlayer) {
                        statusMessage.textContent = "시간 초과! 무작위 위치에 돌을 놓습니다.";
                        await makeRandomMove();
                    }
                } else {
                    timerDisplay.textContent = `남은 시간: ${timeLeft}초`;
                }
            }, 1000);
        }
        
        async function makeRandomMove() { if (!lastKnownGameData) return; const { board } = lastKnownGameData; const emptySpots = []; for (let y = 0; y < BOARD_SIZE; y++) { for (let x = 0; x < BOARD_SIZE; x++) { if (board[y][x] === 0) { if (myPlayerNumber === 1 && isForbiddenMove(x, y, board)) continue; emptySpots.push({ x, y }); } } } if (emptySpots.length === 0) { statusMessage.textContent = "둘 곳이 없습니다! 턴을 넘깁니다."; const updatedData = { ...lastKnownGameData, currentPlayer: myPlayerNumber === 1 ? 2 : 1 }; await set(ref(database, `omok_rooms/${currentRoomId}`), updatedData); return; } const { x, y } = emptySpots[Math.floor(Math.random() * emptySpots.length)]; await placeStone(x, y, myPlayerNumber, lastKnownGameData); }
        
        // --- ▼▼▼ 렌주룰 핵심 로직 (재검토 및 강화) ▼▼▼ ---
        function checkWin(x, y, player, board) {
            const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }];
            for (const { dx, dy } of directions) {
                const { count } = analyzeLine(x, y, player, board, dx, dy);
                if (player === 1 && count === 5) return true;
                if (player === 2 && count >= 5) return true;
            }
            return false;
        }

        function isForbiddenMove(x, y, board) {
            const tempBoard = board.map(row => [...row]);
            tempBoard[y][x] = 1;
            const directions = [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }];
            let openThreeCount = 0;
            let fourCount = 0;

            for (const { dx, dy } of directions) {
                const { count, openEnds } = analyzeLine(x, y, 1, tempBoard, dx, dy);
                if (count > 5) return "장목";
                // 5목이 만들어지는 경우는 금수가 아님 (5목 우선)
                if (count === 5) return null; 

                // 돌을 놓음으로써 완성된 패턴만 카운트
                const lineInfo = analyzeLine(x, y, 1, tempBoard, dx, dy, true);
                if (lineInfo.isFour) fourCount++;
                if (lineInfo.isOpenThree) openThreeCount++;
            }

            if (fourCount >= 2) return "4-4";
            if (openThreeCount >= 2) return "3-3";
            return null;
        }

        function analyzeLine(x, y, player, board, dx, dy, checkForCreation = false) {
            let count = 1;
            let openEnds = 0;

            // 정방향
            let line = [player];
            for (let i = 1; i < 6; i++) {
                const nx = x + i * dx;
                const ny = y + i * dy;
                if (board[ny]?.[nx] === player) {
                    count++;
                    line.push(player);
                } else {
                    if (board[ny]?.[nx] === 0) {
                        openEnds++;
                        line.push(0);
                    } else {
                        line.push(2-player+1); // 상대방 돌
                    }
                    break;
                }
            }
            // 역방향
            let preLine = [];
            for (let i = 1; i < 6; i++) {
                const nx = x - i * dx;
                const ny = y - i * dy;
                if (board[ny]?.[nx] === player) {
                    count++;
                    preLine.unshift(player);
                } else {
                    if (board[ny]?.[nx] === 0) {
                        openEnds++;
                        preLine.unshift(0);
                    } else {
                         preLine.unshift(2-player+1);
                    }
                    break;
                }
            }
            
            if (!checkForCreation) return { count, openEnds };
            
            // 패턴 생성 여부 분석
            const fullLine = preLine.concat(line);
            const lineStr = fullLine.join('');
            
            let isOpenThree = false;
            if (lineStr.includes('01110')) isOpenThree = true; // 열린 3
            if (lineStr.match(/011010|010110/)) isOpenThree = true; // 떨어진 3
            
            let isFour = false;
            if (count === 4) isFour = true;

            return { count, openEnds, isOpenThree, isFour };
        }
        
        window.addEventListener('beforeunload', (e) => { if (currentRoomId) { remove(ref(database, `omok_rooms/${currentRoomId}`)).catch(()=>{}); } });
    </script>
</body>
</html>